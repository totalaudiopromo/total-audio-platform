-- ========================================
-- PR Autopilot System Database Schema
-- ========================================
-- Purpose: Multi-Agent PR Autopilot orchestration layer
--
-- This migration creates 6 new tables for the PR Autopilot system:
-- 1. autopilot_missions - High-level PR campaign missions
-- 2. autopilot_tasks - Granular agent work items
-- 3. autopilot_runs - Execution session tracking
-- 4. autopilot_logs - Audit and debug logging
-- 5. autopilot_policies - Safety and behaviour policies
-- 6. autopilot_settings - User/workspace preferences
--
-- Integration: This is an ORCHESTRATION layer on top of existing
-- email-engine, list-builder, CMG, fusion-layer, and other TAP systems.
-- ========================================

-- ========================================
-- Table 1: autopilot_missions
-- ========================================
-- Represents a high-level PR mission (campaign or sub-campaign)
CREATE TABLE IF NOT EXISTS autopilot_missions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  campaign_id UUID NULL, -- optional link to existing campaign entity
  mode TEXT NOT NULL CHECK (mode IN ('suggest', 'semi_auto', 'full_auto')) DEFAULT 'suggest',
  status TEXT NOT NULL CHECK (status IN ('draft', 'active', 'paused', 'completed', 'failed')) DEFAULT 'draft',
  config JSONB DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Indexes for missions
CREATE INDEX idx_autopilot_missions_user ON autopilot_missions(user_id);
CREATE INDEX idx_autopilot_missions_workspace ON autopilot_missions(workspace_id);
CREATE INDEX idx_autopilot_missions_status ON autopilot_missions(status);
CREATE INDEX idx_autopilot_missions_mode ON autopilot_missions(mode);
CREATE INDEX idx_autopilot_missions_campaign ON autopilot_missions(campaign_id);

-- RLS for missions
ALTER TABLE autopilot_missions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own missions" ON autopilot_missions
  FOR SELECT
  USING (
    user_id = auth.uid() OR
    workspace_id IN (
      SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can create missions" ON autopilot_missions
  FOR INSERT
  WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own missions" ON autopilot_missions
  FOR UPDATE
  USING (
    user_id = auth.uid() OR
    workspace_id IN (
      SELECT workspace_id FROM workspace_members
      WHERE user_id = auth.uid() AND role IN ('admin', 'member')
    )
  );

CREATE POLICY "Users can delete their own missions" ON autopilot_missions
  FOR DELETE
  USING (
    user_id = auth.uid() OR
    workspace_id IN (
      SELECT workspace_id FROM workspace_members
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- ========================================
-- Table 2: autopilot_tasks
-- ========================================
-- Granular work items generated by and for agents
CREATE TABLE IF NOT EXISTS autopilot_tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mission_id UUID NOT NULL REFERENCES autopilot_missions(id) ON DELETE CASCADE,
  parent_task_id UUID REFERENCES autopilot_tasks(id) ON DELETE SET NULL,
  agent_role TEXT NOT NULL CHECK (
    agent_role IN (
      'strategist', 'pitch', 'contact', 'scheduler',
      'followup', 'analyst', 'archivist', 'simulator', 'coordinator'
    )
  ),
  type TEXT NOT NULL,
  input JSONB NOT NULL DEFAULT '{}'::jsonb,
  output JSONB,
  status TEXT NOT NULL CHECK (
    status IN ('pending', 'in_progress', 'blocked', 'waiting_approval', 'completed', 'failed')
  ) DEFAULT 'pending',
  priority INT NOT NULL DEFAULT 0,
  blocking_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  completed_at TIMESTAMPTZ
);

-- Indexes for tasks
CREATE INDEX idx_autopilot_tasks_mission ON autopilot_tasks(mission_id);
CREATE INDEX idx_autopilot_tasks_parent ON autopilot_tasks(parent_task_id);
CREATE INDEX idx_autopilot_tasks_agent_role ON autopilot_tasks(agent_role);
CREATE INDEX idx_autopilot_tasks_status ON autopilot_tasks(status);
CREATE INDEX idx_autopilot_tasks_priority ON autopilot_tasks(priority DESC);
CREATE INDEX idx_autopilot_tasks_agent_status ON autopilot_tasks(agent_role, status);

-- RLS for tasks (inherit from mission)
ALTER TABLE autopilot_tasks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view tasks for their missions" ON autopilot_tasks
  FOR SELECT
  USING (
    mission_id IN (
      SELECT id FROM autopilot_missions
      WHERE user_id = auth.uid() OR
      workspace_id IN (
        SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
      )
    )
  );

CREATE POLICY "System can manage tasks" ON autopilot_tasks
  FOR ALL
  USING (
    mission_id IN (
      SELECT id FROM autopilot_missions
      WHERE user_id = auth.uid() OR
      workspace_id IN (
        SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
      )
    )
  );

-- ========================================
-- Table 3: autopilot_runs
-- ========================================
-- Execution sessions (nightly runs or manual triggers)
CREATE TABLE IF NOT EXISTS autopilot_runs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mission_id UUID NOT NULL REFERENCES autopilot_missions(id) ON DELETE CASCADE,
  triggered_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  trigger_type TEXT NOT NULL CHECK (trigger_type IN ('manual', 'schedule', 'event')),
  started_at TIMESTAMPTZ DEFAULT now(),
  finished_at TIMESTAMPTZ,
  status TEXT NOT NULL CHECK (status IN ('running', 'succeeded', 'failed', 'partial')) DEFAULT 'running',
  summary JSONB
);

-- Indexes for runs
CREATE INDEX idx_autopilot_runs_mission ON autopilot_runs(mission_id);
CREATE INDEX idx_autopilot_runs_status ON autopilot_runs(status);
CREATE INDEX idx_autopilot_runs_started ON autopilot_runs(started_at DESC);

-- RLS for runs
ALTER TABLE autopilot_runs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view runs for their missions" ON autopilot_runs
  FOR SELECT
  USING (
    mission_id IN (
      SELECT id FROM autopilot_missions
      WHERE user_id = auth.uid() OR
      workspace_id IN (
        SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
      )
    )
  );

CREATE POLICY "System can manage runs" ON autopilot_runs
  FOR ALL
  USING (
    mission_id IN (
      SELECT id FROM autopilot_missions
      WHERE user_id = auth.uid() OR
      workspace_id IN (
        SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
      )
    )
  );

-- ========================================
-- Table 4: autopilot_logs
-- ========================================
-- Low-level log events for audit and debugging
CREATE TABLE IF NOT EXISTS autopilot_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mission_id UUID NOT NULL REFERENCES autopilot_missions(id) ON DELETE CASCADE,
  task_id UUID REFERENCES autopilot_tasks(id) ON DELETE SET NULL,
  agent_role TEXT,
  level TEXT NOT NULL CHECK (level IN ('info', 'warn', 'error', 'debug')) DEFAULT 'info',
  message TEXT NOT NULL,
  metadata JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Indexes for logs
CREATE INDEX idx_autopilot_logs_mission ON autopilot_logs(mission_id);
CREATE INDEX idx_autopilot_logs_task ON autopilot_logs(task_id);
CREATE INDEX idx_autopilot_logs_level ON autopilot_logs(level);
CREATE INDEX idx_autopilot_logs_created ON autopilot_logs(created_at DESC);
CREATE INDEX idx_autopilot_logs_agent ON autopilot_logs(agent_role);

-- RLS for logs
ALTER TABLE autopilot_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view logs for their missions" ON autopilot_logs
  FOR SELECT
  USING (
    mission_id IN (
      SELECT id FROM autopilot_missions
      WHERE user_id = auth.uid() OR
      workspace_id IN (
        SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
      )
    )
  );

CREATE POLICY "System can create logs" ON autopilot_logs
  FOR INSERT
  WITH CHECK (
    mission_id IN (
      SELECT id FROM autopilot_missions
      WHERE user_id = auth.uid() OR
      workspace_id IN (
        SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
      )
    )
  );

-- ========================================
-- Table 5: autopilot_policies
-- ========================================
-- Global and per-workspace safety/behaviour policies
CREATE TABLE IF NOT EXISTS autopilot_policies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
  scope TEXT NOT NULL CHECK (scope IN ('user', 'workspace', 'global')) DEFAULT 'user',
  config JSONB NOT NULL DEFAULT '{
    "allowed_modes": ["suggest"],
    "max_emails_per_day": 50,
    "max_contacts_per_mission": 500,
    "approval_required": ["send_email", "create_campaign", "modify_segment"],
    "quiet_hours": {"start": "22:00", "end": "08:00"},
    "contact_fatigue_days": 14
  }'::jsonb,
  created_at TIMESTAMPTZ DEFAULT now(),

  -- Ensure only one policy per scope
  CONSTRAINT unique_user_policy UNIQUE NULLS NOT DISTINCT (user_id, scope),
  CONSTRAINT unique_workspace_policy UNIQUE NULLS NOT DISTINCT (workspace_id, scope),

  -- Ensure scope matches id fields
  CONSTRAINT check_scope_user CHECK (scope != 'user' OR user_id IS NOT NULL),
  CONSTRAINT check_scope_workspace CHECK (scope != 'workspace' OR workspace_id IS NOT NULL),
  CONSTRAINT check_scope_global CHECK (scope != 'global' OR (user_id IS NULL AND workspace_id IS NULL))
);

-- Indexes for policies
CREATE INDEX idx_autopilot_policies_user ON autopilot_policies(user_id);
CREATE INDEX idx_autopilot_policies_workspace ON autopilot_policies(workspace_id);
CREATE INDEX idx_autopilot_policies_scope ON autopilot_policies(scope);

-- RLS for policies
ALTER TABLE autopilot_policies ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their policies" ON autopilot_policies
  FOR SELECT
  USING (
    scope = 'global' OR
    user_id = auth.uid() OR
    workspace_id IN (
      SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their own policies" ON autopilot_policies
  FOR ALL
  USING (
    scope = 'user' AND user_id = auth.uid()
  );

CREATE POLICY "Workspace admins can manage workspace policies" ON autopilot_policies
  FOR ALL
  USING (
    scope = 'workspace' AND
    workspace_id IN (
      SELECT workspace_id FROM workspace_members
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- ========================================
-- Table 6: autopilot_settings
-- ========================================
-- User-level and workspace-level preferences
CREATE TABLE IF NOT EXISTS autopilot_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
  key TEXT NOT NULL,
  value JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),

  -- Ensure unique key per user or workspace
  CONSTRAINT unique_user_setting UNIQUE NULLS NOT DISTINCT (user_id, key),
  CONSTRAINT unique_workspace_setting UNIQUE NULLS NOT DISTINCT (workspace_id, key),

  -- Ensure at least one of user_id or workspace_id is set
  CONSTRAINT check_setting_owner CHECK (
    (user_id IS NOT NULL AND workspace_id IS NULL) OR
    (user_id IS NULL AND workspace_id IS NOT NULL)
  )
);

-- Indexes for settings
CREATE INDEX idx_autopilot_settings_user ON autopilot_settings(user_id);
CREATE INDEX idx_autopilot_settings_workspace ON autopilot_settings(workspace_id);
CREATE INDEX idx_autopilot_settings_key ON autopilot_settings(key);

-- RLS for settings
ALTER TABLE autopilot_settings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their settings" ON autopilot_settings
  FOR SELECT
  USING (
    user_id = auth.uid() OR
    workspace_id IN (
      SELECT workspace_id FROM workspace_members WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can manage their own settings" ON autopilot_settings
  FOR ALL
  USING (user_id = auth.uid());

CREATE POLICY "Workspace admins can manage workspace settings" ON autopilot_settings
  FOR ALL
  USING (
    workspace_id IN (
      SELECT workspace_id FROM workspace_members
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );

-- ========================================
-- Triggers for updated_at timestamps
-- ========================================

CREATE OR REPLACE FUNCTION update_autopilot_missions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER autopilot_missions_updated_at
  BEFORE UPDATE ON autopilot_missions
  FOR EACH ROW
  EXECUTE FUNCTION update_autopilot_missions_updated_at();

CREATE OR REPLACE FUNCTION update_autopilot_tasks_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    NEW.completed_at = now();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER autopilot_tasks_updated_at
  BEFORE UPDATE ON autopilot_tasks
  FOR EACH ROW
  EXECUTE FUNCTION update_autopilot_tasks_updated_at();

CREATE OR REPLACE FUNCTION update_autopilot_settings_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER autopilot_settings_updated_at
  BEFORE UPDATE ON autopilot_settings
  FOR EACH ROW
  EXECUTE FUNCTION update_autopilot_settings_updated_at();

-- ========================================
-- Helper Functions
-- ========================================

-- Function: Get active mission count for user
CREATE OR REPLACE FUNCTION get_user_active_missions(p_user_id UUID)
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM autopilot_missions
    WHERE user_id = p_user_id
    AND status IN ('active', 'paused')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Get pending task count for mission
CREATE OR REPLACE FUNCTION get_mission_pending_tasks(p_mission_id UUID)
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM autopilot_tasks
    WHERE mission_id = p_mission_id
    AND status IN ('pending', 'in_progress')
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Check if user can run mission in mode
CREATE OR REPLACE FUNCTION can_user_run_mission_mode(
  p_user_id UUID,
  p_workspace_id UUID,
  p_mode TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
  v_policy JSONB;
  v_allowed_modes JSONB;
BEGIN
  -- Get applicable policy (workspace > user > global)
  SELECT config INTO v_policy
  FROM autopilot_policies
  WHERE (
    (scope = 'workspace' AND workspace_id = p_workspace_id) OR
    (scope = 'user' AND user_id = p_user_id) OR
    (scope = 'global')
  )
  ORDER BY
    CASE scope
      WHEN 'workspace' THEN 1
      WHEN 'user' THEN 2
      WHEN 'global' THEN 3
    END
  LIMIT 1;

  -- If no policy, default to suggest mode only
  IF v_policy IS NULL THEN
    RETURN p_mode = 'suggest';
  END IF;

  v_allowed_modes := v_policy->'allowed_modes';

  -- Check if mode is in allowed list
  RETURN v_allowed_modes ? p_mode;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ========================================
-- Table Comments
-- ========================================

COMMENT ON TABLE autopilot_missions IS 'PR Autopilot missions - high-level campaign orchestration';
COMMENT ON TABLE autopilot_tasks IS 'Agent work items - granular tasks executed by specialized agents';
COMMENT ON TABLE autopilot_runs IS 'Execution sessions - tracking of autopilot run history';
COMMENT ON TABLE autopilot_logs IS 'Audit and debug logs for autopilot operations';
COMMENT ON TABLE autopilot_policies IS 'Safety and behaviour policies for autopilot system';
COMMENT ON TABLE autopilot_settings IS 'User and workspace preferences for autopilot';

COMMENT ON COLUMN autopilot_missions.mode IS 'Operation mode: suggest (human approval), semi_auto (safe auto), full_auto (trusted auto within limits)';
COMMENT ON COLUMN autopilot_missions.config IS 'Strategy configuration, constraints, and preferences for the mission';
COMMENT ON COLUMN autopilot_tasks.agent_role IS 'Which agent is responsible: strategist, pitch, contact, scheduler, followup, analyst, archivist, simulator, coordinator';
COMMENT ON COLUMN autopilot_tasks.type IS 'Task type specific to agent role (e.g., plan_campaign, generate_pitch, select_contacts)';
COMMENT ON COLUMN autopilot_tasks.priority IS 'Higher numbers = higher priority (default 0)';
COMMENT ON COLUMN autopilot_runs.trigger_type IS 'How the run was triggered: manual, schedule, or event';
COMMENT ON COLUMN autopilot_policies.scope IS 'Policy scope: user, workspace, or global';
COMMENT ON COLUMN autopilot_policies.config IS 'Policy configuration including allowed modes, limits, and restrictions';

-- ========================================
-- ROLLBACK SCRIPT (if needed)
-- ========================================
-- DROP TABLE IF EXISTS autopilot_settings CASCADE;
-- DROP TABLE IF EXISTS autopilot_policies CASCADE;
-- DROP TABLE IF EXISTS autopilot_logs CASCADE;
-- DROP TABLE IF EXISTS autopilot_runs CASCADE;
-- DROP TABLE IF EXISTS autopilot_tasks CASCADE;
-- DROP TABLE IF EXISTS autopilot_missions CASCADE;
-- DROP FUNCTION IF EXISTS get_user_active_missions(UUID);
-- DROP FUNCTION IF EXISTS get_mission_pending_tasks(UUID);
-- DROP FUNCTION IF EXISTS can_user_run_mission_mode(UUID, UUID, TEXT);
-- DROP FUNCTION IF EXISTS update_autopilot_missions_updated_at();
-- DROP FUNCTION IF EXISTS update_autopilot_tasks_updated_at();
-- DROP FUNCTION IF EXISTS update_autopilot_settings_updated_at();
-- ========================================
